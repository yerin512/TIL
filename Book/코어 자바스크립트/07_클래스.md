
# 7장 클래스

자바스크립트는 프로토타입 기반 언어라서 상속 개념이 존재하지 않음. 클래스와 비슷하게 동작하게끔 흉내 내는 여러 기법들이 탄생했음. 결국 ES6에는 클래스 문법이 추가됐음. 다만 ES6의 클래스에서도 일정 부분은 프로토타입을 활용하고 있음.

## 7.1 클래스와 인스턴스의 개념 이해

클래스는 객체지향 프로그래밍에서 거의 반드시 등장하는 제1요소임. 
음식이라는 범주 안에는 고기, 과일 채소 등이 들어있을 것이고
과일이라는 범주 아래에는 배, 사과, 바나나 등등이 포함될 것임. 배, 사과, 바나나 등은 직접 만질 수 있고 볼 수 있는 구체적이고 실존하는 사물임.

반면, 음식이나 과일은 추상적인 개념임. 하지만 음식은 과일과의 관계에서 상위의 개념이고 과일은 하위의 개념임.

음식, 과일은 클래스임. 음식은 과일보다 상위 개념 (superior)
과일은 음식보다 하위의 개념 (subordinate) 이다.
상위 클래스(superclass)/ 하위 클래스(subclass)로 표현한다.

클래스는 하위로 갈수록 상위 클래스의 속성을 상속하면서 더 구체적인 요건이 추가 또는 변경된다.
하위 클래스가 아무리 구체화되더라도 이들은 결국 추상적인 개념일 뿐이다. 
이거는 상위 클래스를 말하는 것 같다.

어떤 클래스의 속성을 지니는 실존하는 개체를 인스턴스(instance)라고 한다.
영한사전에는 사례라고 번역하고 있고, 풀어쓰면 '어떤 조건에 부합하는 구체적인 예시'가 된다.
여기서 조건이 클래스를 의미한다면 어떤 클래스에 속한 개체는 그 클래스의 조건을 모두 만족하므로 그 클래스의 구체적인 예시, 즉 인스턴스가 될 것이다.

프로그래밍 언어에서의 클래스는 현실세계에서의 클래스와 마찬가지로 '공통요소를 지니는 집단을 분류하기 위한 개념'이라는 측면에서는 일치하지만 인스턴스들로부터 공통점을 발견해서 클래스를 정의하는 현실과 달리, 클래스가 먼저 정의돼야만 그로부터 공통적인 요소를 지니는 개체들을 생성할 수 있다.
프로그래밍 언어에서의 클래스는 추상적인 대상일 수도 있고 구체적인 개체가 될 수도 있다.


## 7.2 자바스크립트의 클래스

자바스크립트는 프로토타입 기반 언어이므로 클래스의 개념이 존재하지 않는다. 하지만 프로토타입을 일반적인 의미에서의
클래스 관점에서 접근해보면 비슷하게 해석할 수 있는 요소가 없지는 않다.

예로, 생성자 함수 Array를 new 연산자와 함께 호출하면 인스턴스가 생성된다. 이때 Array를 일종의 클래스라고 하면,
Array의 prototype 객체 내부 요소들이 인스턴스에 '상속'된다고 볼 수 있다.
엄밀히는 상속이 아닌 프로토타입 체이닝에 의한 참조지만 결과적으론 동일하게 동작하니 이렇게 이해해도 무방하다.
한편 Array 내부 프로퍼티들 중 prototype 프로퍼티를 제외한 나머지는 인스턴스에 상속되지 않는다.

인스턴스에 상속되는지(인스턴스가 참조하는지) 여부에 따라 스태틱 멤버와 인스턴스 멤버로 나뉜다. 
클래스 입장에서 사용 대상에 따라 구분한 것이다. 여느 클래스 기반 언어와 달리 자바스크립트에서는 인스턴스에서도 직접 메서드를 정의할 수 있기 때문에 '인스턴스 메서드'라는 명칭은 프로토타입에 정의한 메서드를 지칭하는 것인지
인스턴스에 정의한 메서드를 정의하는 것인지에 대해 혼란을 야기한다.
따라서 이 명칭 대신 자바스크립트의 특징을 살려 프로토타입 메서드라고 부르는 편이 더 좋을 것이다.

인스턴스에서 직접 호출할 수 있는 메서드 : 프로토타입 메서드
인스턴스에서 직접 접근할 수 없는메서드 : 스태틱 메서드 생성자함수를 this로 해야 호출 가능

구체적인 인스턴스가 사용할 메서드를 정의한 '틀'의 역할을 담당하는 목적을 가질 때의 클래스는 추상적인 개념이지만,
클래스 자체를 this로 해서 직접 접근해야만 하는 스태틱 메서드를 호출할 때의 클래스는 그 자체가 하나의 개체로 취급됨.

## 7.3 클래스 상속

### 7.3.1 기본 구현

클래스 상속은 객체 지향에서 가장 중요한 요소중 하나임. 이 때문에 ES5까지는 클래스 상속을 다른 객체지향 언어에 익숙한 개발자들에게 최대한 친숙한 형태로 흉내 내는 것이 가장 주요한 관심사였음.
프로토타입 체인을 활용해 클래스 상속을 구현하고 최대한 전통적인 객체지향 언어에서의 클래스와 비슷한 형태로 발전시켜 보자.

하위 클래스로 삼을 생성자 함수의 prototype에 상위 클래스의 인스턴스를 부여하는 것망느로도 기본적인 메서드 상속은 가능하지만 다양한 문제가 발생할 여지가 있어 안정성이 떨어진다.

### 7.3.2 클래스가 구체적인 데이터를 지니지 않게 하는 방법

가장 쉬운 방법은 일단 만들고 나서 프로퍼티들을 일일이 지우고 더는 새로운 프로퍼티를 추가할수 없게 하는 것.

두 번째 방법은 아무런 프로퍼티를 생성하지 않는 빈 생성자 함수를 하나 더 만들어서 그 prototype이 superclass의 prototype을 바라보게 한 뒤 subclss의 prototype에는 빈 생성자 함수의 인스턴스를 할당하게 하는 것.
빈 함수를 다리역할로 쓰는 것임.

세 번째 방법은 Object.create를 활용하는 방법. (ES5에서 도입됨)
subclss의 prototype의 __proto_가 super class의 prototype을 바라보되, superclass의 인스턴가 되지는 않으므로 간단하면서 안전함.

클래스 상속 및 추상화를 흉내내기 위한 라이브러리가 많이 있지만 기본적인 접근 방법은 위 세 가지 아이디어를 벗어나지 않음.
결국 sub class.prototype의 __proto__가 super class.prototpye을 참조하고,
subclass.prototpye에는 불필요한 인스턴스 프로퍼티가 남아있지 않게 하는 것이니까.

### 7.3.3 constructor 복구하기

위 세 가지 방법 모두 기본적인 상속에는 성공했지만 subclass 인스턴스의 constructor는 여전히 super class를 가리키는 상태임. 엄밀히는 subclass 인스턴스에는 constrouctor가 없고, subclss.prototpye에도 없는 상황.
프로토타입 체인상에서 가장 먼저 등장하는 superclass.prototype의 constrouctor에서 가리키는 대상, 즉 superclass가 출력될 뿐임.
따라서 subclss.prototpye.constructor가 원래의 subclass를 바라보도록 해주면 됨.
이렇게 가장 기본적인 기능인 상속 및 추상화를 달성했음.

## 7.4 ES6의 클래스 및 클래스 상속


ES6에서는 본격적으로 클래스 문법이 도입됨. ES5 체계에서의 생성자 함수 및 프로토타입과 ES6의 클래스 문법을 비교해보자.

메서드와 다음 메서드 사이에는 콤마로 구분하지 않음.
static 메서드임을 알리기 위해 static 키워드를 앞에 붙이며 생성자 함수(클래스) 자신만이 호출 가능
그냥 메서드들은 prototype 객체 내부에 할당되는 메서드임. 인스턴스가 프로토타입 체이닝을 통해 마치 자신의 것처럼 호출할수 있는 메서드임.

'extends superclass' 라는 내용을 추가함으로 상속 관계 설정이 끝남.

constructor 내부에서는 super라는 키워드를 함수처럼 쓸 수 있는데, 이 함수는 superClass.prototype을 바라봄.
호출한 메서드의 this는 super가 아닌 원래의 this를 그대로 따름.

constructor 메서드를 제외한 다른 메서드에서는 super 키워드를 마치 객체처럼 사용할 수 있음.
이때 객체는 superClass.prototype을 바라봄. 호출한 메서드의 this는 super가 아니라 원래의 this를 그대로 따름.

# 7.5 정리

자바스크립트는 프로토타입 기반 언어라서 클래스 및 상속 개념은 존재하지 않지만 프로토타입을 기반으로 클래스와 비슷하게 동작하게끔 하는 다양한 기법들이 도입돼 왔음.

클래스는 어떤 사물의 공통 속성을 모아 정의한 추상적인 개념이고, 인스턴스는 클래스의 속성을 지니는 구체적인 사례임.
상위 클래스(super class)의 조건을 충족하면서 더욱 구체적인 조건이 추가된 것을 하위 클래스(sub class)라고 함.

클래스의 prototype 내부에 정의된 메서드를 프로토타입 메서드라 하고, 이들은 인스턴스가 자신의 것처럼 호출 가능.
한편 클래스(생성자 함수)에 직접 정의한 메서드를 스태틱 메서드라고 하며, 이들은 인스턴스가 직접 호출할 수 없고 클래스(생성자 함수)에 의해서만 호출 가능함.


