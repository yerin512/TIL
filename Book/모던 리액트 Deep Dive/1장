
책을 읽으면서 문제로 나올 것 같거나 몰랐던 부분, 나중을 위해 메모하고 싶은 부분을 기록한다.



1.1장 동등 비교
Object.is란 무엇인가?

==와 ===가 만족하지 못하는 몇 가지 특이한 케이스를 극복하기 위해 ES6 때 새로 도입됐다.
아래는 책에 나와있는 예시다. 

-0 === +0 //true
Object.is(-0, +0) //false

Number.NaN === NaN // false
Object.is(Number.NaN, NaN) //true

NaN === 0 / 0 // false
Object.is(NaN, 0 / 0) //true




리액트에서 사용하는 동등 비교는 == 나 ===가 아닌 Object.is다.

정확히는, Object.is 로 먼저 비교 한 뒤, Object.is로는 못하는 객체 간 얕은 비교를 한 번 더 한다.
참고로 객체의 첫 번쨰 깊이에 존재하는 값만 비교하는 게 객체 간 얕은 비교이다.

왜 객체의 얕은 비교까지만 구현하는가? 바로 리액트에서 사용되는 JSX props는 객체이며 props만 일차적으로 비교하면 되기 때문이다.

더 깊은 객체까지 비교하려면 성능에 악영향을 끼쳤을 것이니 이게 최선이라 볼 수 있겠다.

리액트 컴포넌트 렌더링이 일어나는는 이유 중 하나는 props의 동등 비교에 따른 결과다.
1.2 함수


리액트에서 컴포넌트를 만드는 함수를 살펴보자

function Component(props){
 return <div>{props.hello}</div>
}


일반적인 함수와의 차이점은 자바스크립트에서는 Component(props) 형태로 호출하지만

함수 컴포넌트는 <Component hello={props.hello}/> 같이 JSX 문법으로 props를 매개변수를 받는다.

하지만 이런 JSX식 말고도 일반적인 자바스크립트 문법으로도 함수 컴포넌트를 호출할 수 있다.





// 함수 선언문
function add(a,b){
  return a+b
}

// 함수 표현식
const sum = function(a,b){
  return a+b
}
함수 표현식과 함수 선언식의 차이는?

가장 큰 차이는 호이스팅(hoisting) 여부다. 함수 호이스팅은 함수 선언문이 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트 특징이다. 함수에 대한 선언을 실행 전에 메모리에 등록하기 때문에 가능하다. 함수 표현식의 경우 변수도 호이스팅이 발생하지만, 함수의 호이스팅과는 다르게 var의 경우엔 undefined로 초기화된다. 런타임 시점에 함수가 할당되기 때문에 표현식 아래로 함수 호출을 작성해야한다.



이런 호이스팅 차이점이 있는 거지 둘 중에 뭐가 낫다라고 단언하긴 어렵다. 취향이나 상황에 맞게 작성하면 된다.

함수 선언문 같은 경우엔 어디서든 호출할 수 있고 변수 선언과는 뚜렷하게 구별이 되는 장점이, 함수 표현식인 경우엔 스코프가 길어질 경우 관리가 함수 선언문에 비핸 관리가 편하다는 장점이 있다.



화살표 함수에서는 constructor를 사용할 수 없다. arguments도 존재하지 않는다. 그리고 this 바인딩도 일반 함수와 차이가 난다.

this는 다 알다시피 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다. 화살표 함수 이전까지는 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다. 화살표 함수 내부에선 this를 참조하면 상위 스코프의 this를 그대로 따른다. 별도의 작업을 추가로 하지 않아도 this에 접근할 수 있는게 화살표 함수다. (this가 선언되는 시점에 이미 상위 스코프로 결졍돼 있어서 this를 받아서 사용, 일반 함수는 호출하는 런타임 시점에 결정되는 this를 따름)



리액트에서 함수를 만들 때 주의해야할 사항

1. 함수의 부수 효과를 최대한 억제하라 (side-effect) = 순수 함수 b

-> 부수 효과를 처리하는 훅인 useEffect 사용을 최소화하자!



2. 가능한 함수를 작게 만들어라

-> 파이브 라인스 오브 코드 책을 추천합니다.



3. 누구나 이해할 수 있는 이름을 붙여라

-> useEffect나 useCallback등의 훅에 넘겨주는 콜백 함수에 네이밍을 붙이기도 한다는 건 처음 알았다.

이렇게 이름을 붙이면 useEffect 코드 내에서 무슨 일을 하는지 코드를 유심히 보지 않아도 되는 장점이 있다.

useEffect(fucntion apiRequest(){
 // ...
 },[])


1.3 클래스
16.8 버전이 나오기 전의 레거시 리액트 프로젝트는 클래스 컴포넌트 천지였다. 클래스의 원리는 프로토타입 기반으로 작동한다. 클래스는 특정한 형태의 객체를 반복적으로 만들기 위해 사용되었다. ES6이전 자바스크립트는 클래스라는 개념이 없으니 그 역할은 모두 함수가 도맡았었다.

 

constructor : 생성자, 객체를 생성하는데 사용하는 특수한 메서드. 하나만 존재할 수 있으며 생략도 가능하다.
프로퍼티: 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값.
getter: 클래스에서 무언가 값을 가져올 때 사용된다.
setter: 클래스 필드에 값을 할당할 때 사용된다.
인스턴스 메서드: 클래스 내부에서 선언한 메서드이며 자바스크립트의 prototype에 선언되므로 프로토타입 메서드라고 불린다.
정적 메서드 : 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드다. this에는 접근할 수 없다. 하지만 인스턴스를 생성하지 않아도 사용할 수 있고 접근할 수 있기 때문에 여러곳에서 재사용 가능하다. 그래서 유틸 함수를 정적 메서드로 많이 활용한다.
상속 : extends를 사용해 다양한 파생 클래스를 만들 수 있다.
+ prototype에 선언되는 걸 확인하고 싶을 때, __proto__ 보다는 Object.getPrototypeOf 를 사용하도록 하자! 

+ 직접 객체에 선언하지 않았어도 프로토타입에 있는 메서드를 찾아 최상위 객체인 Object까지 훑는걸 프로토타입 체이닝이라한다.

+ 클래스 작동을 생성자 함수로 유사하게 재현할 수 있다. 객체지향 언어에 익숙한 개발자에게 문법적 설탕 역할을 해줬던 것 같다.

 
