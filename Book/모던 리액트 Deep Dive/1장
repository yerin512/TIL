
책을 읽으면서 문제로 나올 것 같거나 몰랐던 부분, 나중을 위해 메모하고 싶은 부분을 기록한다.



1.1장 동등 비교
Object.is란 무엇인가?

==와 ===가 만족하지 못하는 몇 가지 특이한 케이스를 극복하기 위해 ES6 때 새로 도입됐다.
아래는 책에 나와있는 예시다. 

-0 === +0 //true
Object.is(-0, +0) //false

Number.NaN === NaN // false
Object.is(Number.NaN, NaN) //true

NaN === 0 / 0 // false
Object.is(NaN, 0 / 0) //true




리액트에서 사용하는 동등 비교는 == 나 ===가 아닌 Object.is다.

정확히는, Object.is 로 먼저 비교 한 뒤, Object.is로는 못하는 객체 간 얕은 비교를 한 번 더 한다.
참고로 객체의 첫 번쨰 깊이에 존재하는 값만 비교하는 게 객체 간 얕은 비교이다.

왜 객체의 얕은 비교까지만 구현하는가? 바로 리액트에서 사용되는 JSX props는 객체이며 props만 일차적으로 비교하면 되기 때문이다.

더 깊은 객체까지 비교하려면 성능에 악영향을 끼쳤을 것이니 이게 최선이라 볼 수 있겠다.

리액트 컴포넌트 렌더링이 일어나는는 이유 중 하나는 props의 동등 비교에 따른 결과다.
1.2 함수


리액트에서 컴포넌트를 만드는 함수를 살펴보자

function Component(props){
 return <div>{props.hello}</div>
}


일반적인 함수와의 차이점은 자바스크립트에서는 Component(props) 형태로 호출하지만

함수 컴포넌트는 <Component hello={props.hello}/> 같이 JSX 문법으로 props를 매개변수를 받는다.

하지만 이런 JSX식 말고도 일반적인 자바스크립트 문법으로도 함수 컴포넌트를 호출할 수 있다.





// 함수 선언문
function add(a,b){
  return a+b
}

// 함수 표현식
const sum = function(a,b){
  return a+b
}
함수 표현식과 함수 선언식의 차이는?

가장 큰 차이는 호이스팅(hoisting) 여부다. 함수 호이스팅은 함수 선언문이 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트 특징이다. 함수에 대한 선언을 실행 전에 메모리에 등록하기 때문에 가능하다. 함수 표현식의 경우 변수도 호이스팅이 발생하지만, 함수의 호이스팅과는 다르게 var의 경우엔 undefined로 초기화된다. 런타임 시점에 함수가 할당되기 때문에 표현식 아래로 함수 호출을 작성해야한다.



이런 호이스팅 차이점이 있는 거지 둘 중에 뭐가 낫다라고 단언하긴 어렵다. 취향이나 상황에 맞게 작성하면 된다.

함수 선언문 같은 경우엔 어디서든 호출할 수 있고 변수 선언과는 뚜렷하게 구별이 되는 장점이, 함수 표현식인 경우엔 스코프가 길어질 경우 관리가 함수 선언문에 비핸 관리가 편하다는 장점이 있다.



화살표 함수에서는 constructor를 사용할 수 없다. arguments도 존재하지 않는다. 그리고 this 바인딩도 일반 함수와 차이가 난다.

this는 다 알다시피 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다. 화살표 함수 이전까지는 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다. 화살표 함수 내부에선 this를 참조하면 상위 스코프의 this를 그대로 따른다. 별도의 작업을 추가로 하지 않아도 this에 접근할 수 있는게 화살표 함수다. (this가 선언되는 시점에 이미 상위 스코프로 결졍돼 있어서 this를 받아서 사용, 일반 함수는 호출하는 런타임 시점에 결정되는 this를 따름)



리액트에서 함수를 만들 때 주의해야할 사항

1. 함수의 부수 효과를 최대한 억제하라 (side-effect) = 순수 함수 b

-> 부수 효과를 처리하는 훅인 useEffect 사용을 최소화하자!



2. 가능한 함수를 작게 만들어라

-> 파이브 라인스 오브 코드 책을 추천합니다.



3. 누구나 이해할 수 있는 이름을 붙여라

-> useEffect나 useCallback등의 훅에 넘겨주는 콜백 함수에 네이밍을 붙이기도 한다는 건 처음 알았다.

이렇게 이름을 붙이면 useEffect 코드 내에서 무슨 일을 하는지 코드를 유심히 보지 않아도 되는 장점이 있다.

useEffect(fucntion apiRequest(){
 // ...
 },[])
